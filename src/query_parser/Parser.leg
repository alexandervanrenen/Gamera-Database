%{
#include "Parser.hpp"
#include "Statement.hpp"
#include "util/Utility.hpp"
#include <unistd.h>
#include <sstream>
#include <memory>
#include <iostream>
#include <mutex>

using namespace std;
using namespace dbi::script;

struct Value {
   bool boolean;
   int number;
   string str;

   ColumnIdentifier columnIdentifier;
   TableAccess tableAccess;
   AttributeDeclaration attributeDeclaration;

   vector<AttributeDeclaration> attributeDeclarationVec;
   vector<TableAccess> tableAccessVec;
   vector<ColumnIdentifier> columnIdentifierVec;

   unique_ptr<Statement> statement;
   vector<unique_ptr<Statement>> statements;
};

# define YYSTYPE struct Value

namespace {
unique_ptr<Statement> result;
istringstream input;
static int lineNumber= 0;
static int columnNumber= 0;
}

# define YY_INPUT(buf, result, max, D, G)                           \
   {                                                                \
      int c= input.get();                                           \
      columnNumber++;                                               \
      if ('\n' == c || '\r' == c) {++lineNumber; columnNumber=0;}   \
      result= (EOF == c) ? 0 : (*(buf)= c, 1);                      \
   };

%}

# --------------------------------------------------------------------------------------------------------------
start = s:STATEMENT                                        { result = unique_ptr<BlockStatement>(new BlockStatement(move(s.statements))); }
      | < . >                                              { throw 2; }
# --------------------------------------------------------------------------------------------------------------
STATEMENT = - a:SINGLE                                     { a.statements.push_back(move(a.statement)); }
          ( - s:SINGLE                                     { a.statements.push_back(move(s.statement)); }
          )*                                               { $$ = move(a); }
SINGLE = SELECT - p:PROJECTION - FROM - t:TABLES - SEM     { $$.statement = unique_ptr<SelectStatement>(new SelectStatement(p.columnIdentifierVec, t.tableAccessVec)); }
       | CREATE - TABLE - id:ID - l:LAYOUT - SEM           { $$.statement = unique_ptr<CreateTableStatement>(new CreateTableStatement(id.str, l.attributeDeclarationVec)); }
       | "{" - s:STATEMENT - "}"                           { $$.statement = unique_ptr<BlockStatement>(new BlockStatement(move(s.statements))); }
# --------------------------------------------------------------------------------------------------------------
SELECT = "select"                                          { }
PROJECTION = s:SELECTORNAME                                { s.columnIdentifierVec.push_back(s.columnIdentifier); }
           (- COMMA - i:SELECTORNAME                       { s.columnIdentifierVec.push_back(i.columnIdentifier); }
           )*                                              { $$ = move(s); }
SELECTORNAME = tid:ID POINT cid:ID                         { $$.columnIdentifier = ColumnIdentifier{tid.str, cid.str}; }
             | cid:ID                                      { $$.columnIdentifier = ColumnIdentifier{"", cid.str}; }

FROM = "from"                                              { }
TABLES = t:TABLENAME                                       { t.tableAccessVec.push_back(t.tableAccess); }
       (- COMMA - i:TABLENAME                              { t.tableAccessVec.push_back(i.tableAccess); }
       )*                                                  { $$ = move(t);}
TABLENAME = tid:ID ' ' alias:ID                            { $$.tableAccess = TableAccess{tid.str, alias.str}; }
          | tid:ID                                         { $$.tableAccess = TableAccess{tid.str, ""}; }
# --------------------------------------------------------------------------------------------------------------
CREATE = "create"                                          { }
TABLE = "table"                                            { }
LAYOUT = OPEN - a:ATTRIBUTE                                { a.attributeDeclarationVec.push_back(a.attributeDeclaration); }
       ( - COMMA - i:ATTRIBUTE                             { a.attributeDeclarationVec.push_back(i.attributeDeclaration); }
       )* CLOSE                                            { $$ = move(a); }
ATTRIBUTE = id:ID - t:TYPE - n:NULLABLE                    { $$.attributeDeclaration = AttributeDeclaration{id.str, t.str, n.boolean}; }
TYPE = "integer"                                           { $$.str = string("integer") }
     | "char" - OPEN - n:NUMBER - CLOSE                    { $$.str = string("char " + to_string(n.number)) }
NULLABLE = "not null"                                      { $$.boolean=false; }
         | "null"                                          { $$.boolean=true; }
         | ""                                              { $$.boolean=true; }
# --------------------------------------------------------------------------------------------------------------
ID = < [a-z|A-Z][a-z|A-Z|0-9|_]* >                         { $$.str=string(yytext); }
NUMBER = < [0-9]+ >                                        { $$.number=atoi(yytext); }
- = (' '|'\n'|'\t')*                                       { }
COMMA = ','                                                { }
SEM = ';'                                                  { }
POINT = '.'                                                { }
OPEN = '('                                                 { }
CLOSE = ')'                                                { }
# --------------------------------------------------------------------------------------------------------------

%%


namespace dbi {

namespace script {

mutex parserGuard; // Sorry only one parsing at a time ..

unique_ptr<Statement> parse(const string& query) throw(ParserException)
{
  unique_lock<mutex> l(parserGuard);

  input.clear();
  input.str(query);

  GREG g;
  yyinit(&g);
  while (yyparse(&g));
  yydeinit(&g);

  return move(result);
}

}

}

