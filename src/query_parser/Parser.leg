%{
#include "Parser.hpp"
#include "Statement.hpp"
#include "util/Utility.hpp"
#include <unistd.h>
#include <sstream>
#include <memory>
#include <iostream>
#include <mutex>

using namespace std;
using namespace dbi::script;

struct Value {
   bool boolean;
   int   number;
   std::string string;
};

# define YYSTYPE struct Value

namespace {
std::vector<std::unique_ptr<Statement>> statements;
std::istringstream input;
static int lineNumber= 0;
static int columnNumber= 0;
}

# define YY_INPUT(buf, result, max, D, G)                         \
  {                                                               \
    int c= input.get();                                           \
    columnNumber++;                                               \
    if ('\n' == c || '\r' == c) {++lineNumber; columnNumber=0;}   \
    result= (EOF == c) ? 0 : (*(buf)= c, 1);                      \
  };

%}

start = STATEMENT - SEM (- STATEMENT - SEM)*               { }
      | < . >                                              { throw 2; }

STATEMENT = SELECT - PROJECTION - FROM - TABLES            { }
          | CREATE - TABLE - id:ID - LAYOUT                { reinterpret_cast<CreateStatement*>(statements.back().get())->name = id.string;}

CREATE = "create"                                          { statements.push_back(std::unique_ptr<CreateStatement>(new CreateStatement()));}
TABLE = "table"                                            { }
LAYOUT = OPEN - ATTRIBUTE ( - COMMA - ATTRIBUTE)* CLOSE    { }
ATTRIBUTE = id:ID - t:TYPE - n:NULLABLE                    { reinterpret_cast<CreateStatement*>(statements.back().get())->attributes.push_back(CreateStatement::Attribute{id.string, t.string, n.boolean});}
TYPE = "integer"                                           { $$.string=std::string("integer")}
     | "char" - OPEN - n:NUMBER - CLOSE                    { $$.string=std::string("char " + std::to_string(n.number))}
NULLABLE = "not null"                                      { $$.boolean=false; }
         | "null"                                          { $$.boolean=true; }
         | ""                                              { $$.boolean=true; }

SELECT = "select"                                          { statements.push_back(std::unique_ptr<SelectStatement>(new SelectStatement()));}
PROJECTION = SELECTORNAME (- COMMA - SELECTORNAME)*        { }
SELECTORNAME = tid:ID POINT cid:ID                         { reinterpret_cast<SelectStatement*>(statements.back().get())->selectors.push_back({tid.string, cid.string});}
             | cid:ID                                      { reinterpret_cast<SelectStatement*>(statements.back().get())->selectors.push_back({"", cid.string});}

FROM = "from"                                              { }
TABLES = TABLENAME (- COMMA - TABLENAME)*                  { }
TABLENAME = tid:ID ' ' alias:ID                            { reinterpret_cast<SelectStatement*>(statements.back().get())->sources.push_back({tid.string, alias.string});}
          | tid:ID                                         { reinterpret_cast<SelectStatement*>(statements.back().get())->sources.push_back({tid.string, ""});}


ID = < [a-z|A-Z][a-z|A-Z|0-9|_]* >                         { $$.string=std::string(yytext);}
- = (' '|'\n'|'\t')*                                       { }
COMMA = ','                                                { }
SEM = ';'                                                  { }
POINT = '.'                                                { }
OPEN = '('                                                 { }
CLOSE = ')'                                                { }
NUMBER = < [0-9]+ >                                        { $$.number=atoi(yytext);}

%%

namespace dbi {

namespace script {

mutex parserGuard; // Sorry only one parsing at a time ..

vector<unique_ptr<Statement>> parse(const string& query) throw(ParserException)
{
  unique_lock<mutex> l(parserGuard);

  input.clear();
  input.str(query);
  statements.clear();

  GREG g;
  yyinit(&g);
  while (yyparse(&g));
  yydeinit(&g);

  return move(statements);
}

}

}

