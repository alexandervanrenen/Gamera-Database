%{
#include "Parser.hpp"
#include "Statement.hpp"
#include "util/Utility.hpp"
#include "harriet/Utility.hpp"
#include "harriet/Expression.hpp"
#include <unistd.h>
#include <sstream>
#include <memory>
#include <iostream>
#include <mutex>

using namespace std;
using namespace dbi;
using namespace dbi::script;

struct Value {
   bool boolean;
   int number;

   string str;
   vector<string> stringVec;

   ColumnIdentifier columnIdentifier;
   TableAccess tableAccess;
   AttributeDeclaration attributeDeclaration;

   vector<AttributeDeclaration> attributeDeclarationVec;
   vector<TableAccess> tableAccessVec;
   vector<ColumnIdentifier> columnIdentifierVec;

   unique_ptr<Statement> statement;
   vector<unique_ptr<Statement>> statements;

   unique_ptr<harriet::Value> value;
   vector<unique_ptr<harriet::Value>> valueVec;
};

# define YYSTYPE struct Value

namespace {
unique_ptr<RootStatement> result;
istringstream input;
static int lineNumber= 0;
static int columnNumber= 0;
}

# define YY_INPUT(buf, result, max, D, G)                           \
   {                                                                \
      int c= input.get();                                           \
      columnNumber++;                                               \
      if ('\n' == c || '\r' == c) {++lineNumber; columnNumber=0;}   \
      result= (EOF == c) ? 0 : (*(buf)= c, 1);                      \
   };

%}

# --------------------------------------------------------------------------------------------------------------
start = - a:GlobalSingle                                   { a.statements.push_back(move(a.statement)); }
      ( - s:GlobalSingle                                   { a.statements.push_back(move(s.statement)); }
      )*                                                   { result = util::make_unique<RootStatement>(move(a.statements)); }
      | < . >                                              { throw 2; }
GlobalSingle = - s:SelectStatement                         { $$ = move(s); }
             | - c:CreateTableStatement                    { $$ = move(c); }
             | - i:InsertStatement                         { $$ = move(i); }
# --------------------------------------------------------------------------------------------------------------
SelectStatement = SELECT - p:Projection - FROM - t:Tables - SEM { $$.statement = util::make_unique<SelectStatement>(move(p.columnIdentifierVec), move(t.tableAccessVec)); }
Projection = s:SelectorName                                { s.columnIdentifierVec.push_back(s.columnIdentifier); }
           (- COMMA - i:SelectorName                       { s.columnIdentifierVec.push_back(i.columnIdentifier); }
           )*                                              { $$ = move(s); }
SelectorName = tid:ID POINT cid:ID                         { $$.columnIdentifier = ColumnIdentifier{tid.str, cid.str}; }
             | cid:ID                                      { $$.columnIdentifier = ColumnIdentifier{"", cid.str}; }
Tables = t:TableName                                       { t.tableAccessVec.push_back(t.tableAccess); }
       (- COMMA - i:TableName                              { t.tableAccessVec.push_back(i.tableAccess); }
       )*                                                  { $$ = move(t);}
TableName = tid:ID ' ' alias:ID                            { $$.tableAccess = TableAccess{tid.str, alias.str}; }
          | tid:ID                                         { $$.tableAccess = TableAccess{tid.str, ""}; }
# --------------------------------------------------------------------------------------------------------------
CreateTableStatement = CREATE - TABLE - id:ID - l:Layout - SEM { $$.statement = util::make_unique<CreateTableStatement>(id.str, move(l.attributeDeclarationVec)); }
Layout = OPEN - a:Attribute                                { a.attributeDeclarationVec.push_back(a.attributeDeclaration); }
       ( - COMMA - i:Attribute                             { a.attributeDeclarationVec.push_back(i.attributeDeclaration); }
       )* CLOSE                                            { $$ = move(a); }
Attribute = id:ID - t:TYPE - n:NULLABLE                    { $$.attributeDeclaration = AttributeDeclaration{id.str, t.str, n.boolean}; }
# --------------------------------------------------------------------------------------------------------------
InsertStatement = INSERT - INTO - id:ID - VALUES - v:Values - SEM { $$.statement = util::make_unique<InsertStatement>(id.str, move(v.valueVec)); }
Values = OPEN - a:VALUE                                    { a.valueVec.push_back(move(a.value)); }
       ( - COMMA - i:VALUE                                 { a.valueVec.push_back(move(i.value)); }
       )* CLOSE                                            { $$ = move(a); }
# --------------------------------------------------------------------------------------------------------------
TYPE = "integer"                                           { $$.str = string("integer"); }
     | "float"                                             { $$.str = string("float"); }
VALUE = v:INTEGER                                          { $$.value = move(v.value); }
      | v:FLOAT                                            { $$.value = move(v.value); }
NULLABLE = "not null"                                      { $$.boolean = false; }
         | "null"                                          { $$.boolean = true; }
         | ""                                              { $$.boolean = true; }
# --------------------------------------------------------------------------------------------------------------
ID = < [a-z|A-Z][a-z|A-Z|0-9|_]* >                         { $$.str = string(yytext); }
INTEGER = < [0-9]+ > !'.'                                  { $$.value = util::make_unique<harriet::IntegerValue>(harriet::to_number<int32_t>(yytext)); }
FLOAT = < [0-9]*'.'[0-9]+ >                                { $$.value = util::make_unique<harriet::FloatValue>(harriet::to_number<float>(yytext)); }
- = (' '|'\n'|'\t')*                                       { }
COMMA = ','                                                { }
POINT = "."                                                { }
SEM = ';'                                                  { }
OPEN = '('                                                 { }
CLOSE = ')'                                                { }
# --------------------------------------------------------------------------------------------------------------
SELECT = "select"                                          { }
FROM = "from"                                              { }
CREATE = "create"                                          { }
TABLE = "table"                                            { }
INSERT = "insert"                                          { }
INTO = "into"                                              { }
VALUES = "values"                                          { }
# --------------------------------------------------------------------------------------------------------------

%%


namespace dbi {

namespace script {

namespace {
mutex parserGuard; // Sorry only one parsing at a time ..
}

unique_ptr<RootStatement> parse(const string& query) throw(ParserException)
{
  unique_lock<mutex> l(parserGuard);

  input.clear();
  input.str(query);

  try {
    GREG g;
    yyinit(&g);
    while (yyparse(&g));
    yydeinit(&g);
  } catch (int) {
    throw ParserException("parser error: ", lineNumber, columnNumber);
  }

  return move(result);
}

}

}

