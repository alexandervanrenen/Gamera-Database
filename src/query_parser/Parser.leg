%{
#include <unistd.h>
#include <sstream>
#include <memory>
#include <iostream>

using namespace std;

struct Statement {
   virtual void dump() = 0;
};

struct SelectStatement : public Statement {

   struct Selector { std::string tableIdentifier; std::string columnIdentifier; };
   std::vector<Selector> selectors;

   struct Source { std::string tableIdentifier; std::string alias; };
   std::vector<Source> sources;

   virtual void dump() {
      std::cout << "---------" << std::endl;
      std::cout << "select " << std::endl;
      for(auto iter : selectors)
         std::cout << "    " << iter.tableIdentifier << " " << iter.columnIdentifier << std::endl;
      std::cout << "from " << std::endl;
      for(auto iter : sources)
         std::cout << "    " << iter.tableIdentifier << " " << iter.alias << std::endl;
      std::cout << "---------" << std::endl;
   }
};

struct CreateStatement : public Statement {

   struct Attribute {
      std::string name;
      std::string type;
      bool notNull;
      void dump() {cout << name << " " << type << " " << notNull << endl;}
   };
   std::string name;
   std::vector<Attribute> attributes;
   std::vector<unsigned> primaryKey;

   virtual void dump() {
      std::cout << "---------" << std::endl;
      std::cout << "create " << name << std::endl;
      for(auto& iter : attributes)
         iter.dump();
      std::cout << "---------" << std::endl;
   }
};

struct Value {
   int   number;
   std::string string;
   bool boolean;
};

# define YYSTYPE struct Value

namespace {
std::vector<std::unique_ptr<Statement>> statements;
std::istringstream input;
static int lineNumber= 0;
static int columnNumber= 0;
}

# define YY_INPUT(buf, result, max, D, G)                         \
  {                                                               \
    int c= input.get();                                           \
    columnNumber++;                                               \
    if ('\n' == c || '\r' == c) {++lineNumber; columnNumber=0;}   \
    result= (EOF == c) ? 0 : (*(buf)= c, 1);                      \
  };

%}

start = STATEMENT - SEM (- STATEMENT - SEM)*               { }
      | < . >                                              { throw 2; }

STATEMENT = SELECT - PROJECTION - FROM - TABLES            { }
          | CREATE - TABLE - id:ID - LAYOUT                { reinterpret_cast<CreateStatement*>(statements.back().get())->name = id.string;}

CREATE = "create"                                          { statements.push_back(std::unique_ptr<CreateStatement>(new CreateStatement()));}
TABLE = "table"                                            { }
LAYOUT = OPEN - ATTRIBUTE ( - COMMA - ATTRIBUTE)* CLOSE    { }
ATTRIBUTE = id:ID - t:TYPE - n:NULLABLE                    { reinterpret_cast<CreateStatement*>(statements.back().get())->attributes.push_back(CreateStatement::Attribute{id.string, t.string, n.boolean});}
TYPE = "integer"                                           { $$.string=std::string("integer")}
     | "char" - OPEN - n:NUMBER - CLOSE                    { $$.string=std::string("char " + std::to_string(n.number))}
NULLABLE = "not null"                                      { $$.boolean=false; }
         | "null"                                          { $$.boolean=true; }
         | ""                                              { $$.boolean=true; }

SELECT = "select"                                          { statements.push_back(std::unique_ptr<SelectStatement>(new SelectStatement()));}
PROJECTION = SELECTORNAME (- COMMA - SELECTORNAME)*        { }
SELECTORNAME = tid:ID POINT cid:ID                         { reinterpret_cast<SelectStatement*>(statements.back().get())->selectors.push_back({tid.string, cid.string});}
             | cid:ID                                      { reinterpret_cast<SelectStatement*>(statements.back().get())->selectors.push_back({"", cid.string});}

FROM = "from"                                              { }
TABLES = TABLENAME (- COMMA - TABLENAME)*                  { }
TABLENAME = tid:ID ' ' alias:ID                            { reinterpret_cast<SelectStatement*>(statements.back().get())->sources.push_back({tid.string, alias.string});}
          | tid:ID                                         { reinterpret_cast<SelectStatement*>(statements.back().get())->sources.push_back({tid.string, ""});}


ID = < [a-z|A-Z][a-z|A-Z|0-9|_]* >                         { $$.string=std::string(yytext);}
- = (' '|'\n'|'\t')*                                       { }
COMMA = ','                                                { }
SEM = ';'                                                  { }
POINT = '.'                                                { }
OPEN = '('                                                 { }
CLOSE = ')'                                                { }
NUMBER = < [0-9]+ >                                        { $$.number=atoi(yytext);}

%%

namespace {

void parse(const std::string& string)
{
  input.clear();
  input.str(string);
  GREG g;
  yyinit(&g);
  while (yyparse(&g));
  yydeinit(&g);
}

}

using namespace std;

int main()
{
   try {
      parse("select s.matr, name from studenten,  studenten asd;");
      parse("create table employee (id integer, \n country_id char(2), mgr_id integer, salery integer, first_name char(20), middle char(1), last_name char(20));");
   } catch (int i)  {
      cout << "error " << lineNumber << " " << columnNumber << endl;
   }

  cout << "line number: " << lineNumber << endl;
  cout << "found statements: " << statements.size() << endl;

   for(auto& iter : statements)
      iter->dump();
  return 0;
}

