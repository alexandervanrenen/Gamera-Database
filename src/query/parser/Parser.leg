%{
#include "Parser.hpp"
#include "Statement.hpp"
#include "util/Utility.hpp"
#include "harriet/Utility.hpp"
#include "harriet/Expression.hpp"
#include "harriet/Value.hpp"
#include "harriet/VariableType.hpp"
#include "Common.hpp"
#include <unistd.h>
#include <sstream>
#include <memory>
#include <iostream>
#include <mutex>

using namespace std;
using namespace dbi;
using namespace dbi::script;

struct ReturnValue {

   ReturnValue()
   : value(harriet::Value::createDefault(harriet::VariableType::createUndefinedType()))
   , type(harriet::VariableType::createUndefinedType())
   {}

   bool boolean;
   int number;
   float numberf;

   string str;
   vector<string> stringVec;

   ColumnReference columnReference;
   TableReference tableReference;
   AttributeDeclaration attributeDeclaration;

   vector<pair<string, unique_ptr<harriet::Expression>>> projectionVec;
   vector<AttributeDeclaration> attributeDeclarationVec;
   vector<TableReference> tableReferenceVec;

   unique_ptr<Statement> statement;
   vector<unique_ptr<Statement>> statements;

   harriet::Value value;
   vector<harriet::Value> valueVec;

   unique_ptr<harriet::Expression> expression;
   vector<unique_ptr<harriet::Expression>> expressionVec;

   harriet::VariableType type;
};

# define YYSTYPE struct ReturnValue

namespace {
unique_ptr<RootStatement> result;
istringstream input;
static int lineNumber= 0;
static int columnNumber= 0;
}

# define YY_INPUT(buf, result, max, D, G)                           \
   {                                                                \
      int c= input.get();                                           \
      columnNumber++;                                               \
      if ('\n' == c || '\r' == c) {++lineNumber; columnNumber=0;}   \
      result= (EOF == c) ? 0 : (*(buf)= c, 1);                      \
   };

%}

# --------------------------------------------------------------------------------------------------------------
start = - a:GlobalSingle                                   { a.statements.push_back(move(a.statement)); }
      ( - s:GlobalSingle                                   { a.statements.push_back(move(s.statement)); }
      )* -                                                 { result = util::make_unique<RootStatement>(move(a.statements)); }
      | < . >                                              { throw 2; }
GlobalSingle = - s:SelectStatement                         { $$ = move(s); }
             | - c:CreateTableStatement                    { $$ = move(c); }
             | - i:InsertStatement                         { $$ = move(i); }
# --------------------------------------------------------------------------------------------------------------
SelectStatement = SELECT - p:Projections - FROM - t:Tables - WHERE - c:Predicates - SEM { $$.statement = util::make_unique<SelectStatement>(move(p.projectionVec), move(t.tableReferenceVec), move(c.expressionVec)); }
                | SELECT - p:Projections - FROM - t:Tables - SEM { $$.statement = util::make_unique<SelectStatement>(move(p.projectionVec), move(t.tableReferenceVec), vector<unique_ptr<harriet::Expression>>()); }
Projections = s:Projection                                 { s.projectionVec.push_back(make_pair(s.str, move(s.expression))); }
           (- COMMA - i:Projection                         { s.projectionVec.push_back(make_pair(i.str, move(i.expression))); }
           )*                                              { $$ = move(s); }
Projection = e:Expression - AS - id:ID                     { $$.expression = move(e.expression); $$.str = move(id.str); }
           | e:Expression                                  { $$.expression = move(e.expression); }
Tables = t:TableName                                       { t.tableReferenceVec.push_back(t.tableReference); }
       (- COMMA - i:TableName                              { t.tableReferenceVec.push_back(i.tableReference); }
       )*                                                  { $$ = move(t);}
TableName = tid:ID ' ' alias:ID                            { $$.tableReference = TableReference{tid.str, alias.str}; }
          | tid:ID                                         { $$.tableReference = TableReference{tid.str, ""}; }
Predicates = p:Predicate                                   { p.expressionVec.push_back(move(p.expression)); }
           (- SQL_AND - i:Predicate                        { p.expressionVec.push_back(move(i.expression)); }
           )*                                              { $$.expressionVec = move(p.expressionVec); }
Predicate = e:Expression                                   { $$.expression = move(e.expression); }
# --------------------------------------------------------------------------------------------------------------
CreateTableStatement = CREATE - TABLE - id:ID - l:Layout - SEM { $$.statement = util::make_unique<CreateTableStatement>(id.str, move(l.attributeDeclarationVec)); }
Layout = OPEN - a:Attribute                                { a.attributeDeclarationVec.push_back(a.attributeDeclaration); }
       ( - COMMA - i:Attribute                             { a.attributeDeclarationVec.push_back(i.attributeDeclaration); }
       )* - CLOSE                                          { $$ = move(a); }
Attribute = id:ID - t:TYPE - n:NULLABLE                    { $$.attributeDeclaration = AttributeDeclaration{id.str, t.type, n.boolean}; }
# --------------------------------------------------------------------------------------------------------------
InsertStatement = INSERT - INTO - id:ID - VALUES - v:Values - SEM { $$.statement = util::make_unique<InsertStatement>(id.str, move(v.valueVec)); }
Values = OPEN - a:VALUE                                    { a.valueVec.push_back(move(a.value)); }
       ( - COMMA - i:VALUE                                 { a.valueVec.push_back(move(i.value)); }
       )* CLOSE                                            { $$ = move(a); }
# --------------------------------------------------------------------------------------------------------------
Expression = c:Conjuction                                  { }
            ( - EQ - i:Conjuction                          { c.expression = harriet::Expression::createBinaryExpression(harriet::ExpressionType::TEqualOperator, move(c.expression), move(i.expression)); }
            | - GEQ - i:Conjuction                         { c.expression = harriet::Expression::createBinaryExpression(harriet::ExpressionType::TGreaterEqualOperator, move(c.expression), move(i.expression)); }
            | - LEQ - i:Conjuction                         { c.expression = harriet::Expression::createBinaryExpression(harriet::ExpressionType::TLessEqualOperator, move(c.expression), move(i.expression)); }
            )*                                             { $$.expression = move(c.expression); }
Conjuction = s:Sum                                         { }
           ( - L_AND - i:Sum                               { s.expression = harriet::Expression::createBinaryExpression(harriet::ExpressionType::TAndOperator, move(s.expression), move(i.expression)); }
           | - L_OR - i:Sum                                { s.expression = harriet::Expression::createBinaryExpression(harriet::ExpressionType::TOrOperator, move(s.expression), move(i.expression)); }
           )*                                              { $$.expression = move(s.expression); }
Sum = p:Product                                            { }
    ( - PLUS - i:Product                                   { p.expression = harriet::Expression::createBinaryExpression(harriet::ExpressionType::TPlusOperator, move(p.expression), move(i.expression)); }
    | - MINUS - i:Product                                  { p.expression = harriet::Expression::createBinaryExpression(harriet::ExpressionType::TMinusOperator, move(p.expression), move(i.expression)); }
    )*                                                     { $$.expression = move(p.expression); }
Product = f:Factor                                         { }
        ( - TIMES - i:Product                              { f.expression = harriet::Expression::createBinaryExpression(harriet::ExpressionType::TMultiplicationOperator, move(f.expression), move(i.expression)); }
        | - DIVIDE - i:Product                             { f.expression = harriet::Expression::createBinaryExpression(harriet::ExpressionType::TDivisionOperator, move(f.expression), move(i.expression)); }
        )*                                                 { $$.expression = move(f.expression); }
Factor = OPEN - e:Expression - CLOSE                       { $$.expression = move(e.expression); }
       | v:VALUE                                           { $$.expression = harriet::Expression::createValueExpression(move(v.value)); }
       | c:ColumnReference                                 { $$.expression = harriet::Expression::createVariableExpression(c.columnReference.str()); }
ColumnReference = tid:ID POINT cid:ID                      { $$.columnReference = ColumnReference{tid.str, cid.str}; }
                | cid:ID                                   { $$.columnReference = ColumnReference{"", cid.str}; }
# --------------------------------------------------------------------------------------------------------------
TYPE = INTEGER_ID                                          { $$.type = harriet::VariableType::createIntegerType(); }
     | FLOAT_ID                                            { $$.type = harriet::VariableType::createFloatType(); }
     | CHARACTER_ID OPEN - i:INTEGER_VAL - CLOSE ![a-z|A-Z]{ $$.type = harriet::VariableType::createCharacterType(i.number); }
     | CHARACTER_ID ![a-z|A-Z]                             { $$.type = harriet::VariableType::createCharacterType(1); }
     | BOOL_ID                                             { $$.type = harriet::VariableType::createBoolType(); }
VALUE = v:INTEGER_VAL                                      { $$.value = harriet::Value::createInteger(v.number); }
      | v:FLOAT_VAL                                        { $$.value = harriet::Value::createFloat(v.numberf); }
      | v:STRING_VAL                                       { $$.value = harriet::Value::createCharacter(v.str, v.str.size()); }
      | v:BOOL_VAL                                         { $$.value = harriet::Value::createBool(v.boolean); }
NULLABLE = "not null"                                      { $$.boolean = false; }
         | "null"                                          { $$.boolean = true; }
         | ""                                              { $$.boolean = true; }
# --------------------------------------------------------------------------------------------------------------
ID = !KEYWORDS < [a-z|A-Z][a-z|A-Z|0-9|_]* >               { $$.str = string(yytext); }
INTEGER_VAL = (PLUS|MINUS)* < [0-9]+ > !'.'                { $$.number = harriet::to_number<int32_t>(yytext); }
FLOAT_VAL = (PLUS|MINUS)* < [0-9]*'.'[0-9]+ >              { $$.numberf = harriet::to_number<float>(yytext); }
STRING_VAL = '\'' < [^\']* > '\''                          { $$.str = string(yytext); }
BOOL_VAL = TRUE                                            { $$.boolean = true; }
         | FALSE                                           { $$.boolean = false; }
- = (' '|'\n'|'\t')*                                       { }
COMMA = ','                                                { }
POINT = "."                                                { }
SEM = ';'                                                  { }
OPEN = '('                                                 { }
CLOSE = ')'                                                { }
PLUS = '+'                                                 { }
MINUS = '-'                                                { }
TIMES = '*'                                                { }
DIVIDE = '/'                                               { }
EQ = "=" | "=="                                            { }
GEQ = ">="                                                 { }
LEQ = "<="                                                 { }
L_AND = "&"                                                { }
L_OR = "|"                                                 { }
# --------------------------------------------------------------------------------------------------------------
KEYWORDS = SELECT | FROM | CREATE | TABLE | INSERT | INTO | VALUES | WHERE | TYPE | AS { }
SELECT = "select"                     ![a-z|A-Z]           { }
FROM = "from"                         ![a-z|A-Z]           { }
CREATE = "create"                     ![a-z|A-Z]           { }
TABLE = "table"                       ![a-z|A-Z]           { }
INSERT = "insert"                     ![a-z|A-Z]           { }
INTO = "into"                         ![a-z|A-Z]           { }
VALUES = "values"                     ![a-z|A-Z]           { }
WHERE = "where"                       ![a-z|A-Z]           { }
AS = "as"                             ![a-z|A-Z]           { }
TRUE = "true"                         ![a-z|A-Z]           { }
FALSE = "false"                       ![a-z|A-Z]           { }
SQL_AND = "and"                       ![a-z|A-Z]           { }
INTEGER_ID = "integer"                ![a-z|A-Z]           { }
FLOAT_ID = "float"                    ![a-z|A-Z]           { }
CHARACTER_ID = "character"|"char"     ![a-z|A-Z]           { }
BOOL_ID = "bool"                      ![a-z|A-Z]           { }
# --------------------------------------------------------------------------------------------------------------

%%


namespace dbi {

namespace script {

namespace {
mutex parserGuard; // Sorry only one parsing at a time ..
}

unique_ptr<RootStatement> parse(const string& query) throw(ParserException)
{
  unique_lock<mutex> l(parserGuard);

  input.clear();
  input.str(query);

  lineNumber = 1;
  columnNumber = 0;

  GREG g;
  try {
    yyinit(&g);
    while (yyparse(&g));
    yydeinit(&g);
  } catch (int) {
    yydeinit(&g);
    throw ParserException("parser error: ", lineNumber, columnNumber);
  }

  if(result == nullptr)
     return util::make_unique<RootStatement>(std::vector<std::unique_ptr<Statement>>());
  return move(result);
}

}

}

